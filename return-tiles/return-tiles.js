var width = 770,
    height = 750,
    xmargin = 70,
    ymargin = 50;

var calcType = "returns";
var fname = "ff-mkt.json";

// colors generated by colorbrewer:
var colorScale = d3.scale.linear()
    .domain([-2, -1, 0, 1, 2, 3])
    .range(["#ca0020", "#f4a582","#f7f7f7","#d1e5f0","#67a9cf", "#2166ac"]);

var svg = d3.select("div#heatmap")
    .append("svg")
      .attr("width", width)
      .attr("height", height);

d3.selectAll("input[name=datasource]")
  .data(["ff-mkt.json", "ff-smb.json", "ff-hml.json"])
    .on("change", function(newFname) {
      fname = newFname;
      execute();
    });

d3.selectAll("input[name=calculation]")
  .data(["returns", "stdev", "sharpe"])
    .on("change", function(newCalcType) {
      calcType = newCalcType;
      execute();
    });

function scoreStdev(s) {
  if (s > .25) {
    return -2; // extreme volatility
  } else if (s > 0.19) {
    return -1; // very high volatility
  } else if (s > 0.18) {
    return 0; // high volatility
  } else if (s > 0.16) {
    return 1; // moderate volatility
  } else if (s > 0.14) {
    return 2; // low volatility
  } else {
    return 3; // no volatility
  }
}

function scoreSharpe(r) {
  if (r < 4.5) {
    return -2; // large loss
  } else if (r < 5.5) {
    return -1; // small loss
  } else if (r < 6.5) {
    return 0; // flat
  } else if (r < 7) {
    return 1; // small gain
  } else if (r < 7.5) {
    return 2; // medium gain
  } else {
    return 3; // large gain
  }
}

function scoreReturn(r) {
  if (r < .97) {
    return -2; // large loss
  } else if (r < 1.00) {
    return -1; // small loss
  } else if (r < 1.03) {
    return 0; // flat
  } else if (r < 1.06) {
    return 1; // small gain
  } else if (r < 1.09) {
    return 2; // medium gain
  } else {
    return 3; // large gain
  }
}

function calc(timeseries) {
  var grid = [];

  for (var i=0; i<timeseries.length; i++) {
    var start = timeseries[i];
    var mean = 0;
    var hold = 0;
    var M2 = 0;
    var cumr = 1;
    for (var j=i; j<timeseries.length; j++) {
      var point = timeseries[j];
      cumr *= 1 + point.r;
      hold += 1;
      var delta = point.r - mean;
      mean += delta / hold;
      M2 += delta * (point.r - mean);
      var stdev = Math.sqrt(M2 / (hold - 1));
      var geomean = Math.pow(cumr, 1/hold);
      var sharpe = geomean / stdev;
      var score = calcType == "returns" ? scoreReturn(geomean) : calcType == "stdev" ? scoreStdev(stdev) : scoreSharpe(sharpe);
      var cell = { "start": start.dt, "end": point.dt, "cumr": cumr, "mean": mean, "sharpe": sharpe, "stdev": stdev, "geomean": geomean, "score": score };
      if (j > i) {
        grid.push(cell);
      }
    }
  }

  return grid;
}

function render(data) {
  if (data === null || data.length === 0) {
    return;
  }

  // first, remove old chart if one exists:
  svg.select("g").remove();

  // now add a new chart:
  var chart = svg.append("g");

  // find our domain and range:
  var firstBuy = data[0].start;
  var firstSell = data[0].end;
  var lastBuy = data[data.length-1].start;
  var lastSell = data[data.length-1].end;

  // each cell should be a square, and all cells should be
  // able to fit inside the SVG element with room to spare
  // for the axes.
  var cellWidth = (width - xmargin) / (lastSell - firstSell);
  var cellHeight = (height - ymargin) / (lastBuy - firstBuy);
  var cellSize = Math.floor(Math.min(cellHeight, cellWidth));

  var heatmapWidth = (lastSell - firstSell + 1) * cellSize;
  var heatmapHeight = (lastBuy - firstBuy + 1) * cellSize;

  // create our axes using previously-calculated domain and range:
  var xscale = d3.scale.linear().domain([firstSell, lastSell]).range([0, heatmapWidth]);
  var yscale = d3.scale.linear().domain([firstBuy, lastBuy]).range([heatmapHeight, 0]);
  var xaxis = d3.svg.axis()
    .scale(xscale)
    .outerTickSize(0)
    .tickFormat(d3.format("f"))
    .orient("bottom");
  var yaxis = d3.svg.axis()
    .scale(yscale)
    .outerTickSize(0)
    .tickFormat(d3.format("f"))
    .orient("right");

  // render the heatmap:
  chart.selectAll().data(data, function(d) { return d.start + ':' + d.end; })
    .enter().append("svg:rect")
      .attr("x", function(d) { return (d.end - firstSell) * cellSize; })
      .attr("y", function(d) { return (lastBuy - d.start) * cellSize; })
      .attr("width", cellSize)
      .attr("height", cellSize)
      .style("fill", function(d) { return colorScale(d.score); });

  // render both axes:
  chart.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + heatmapHeight + ")")
    .call(xaxis);
  chart.append("g")
    .attr("class", "y axis")
    .attr("transform", "translate(" + heatmapWidth + ",0)")
    .call(yaxis);

  // render axis labels:
  chart.append("text")
    .attr("transform", "translate(" + (heatmapWidth + 60) + "," + (heatmapHeight / 2) + ")rotate(-90)")
    .text("Buy");
  chart.append("text")
    .attr("transform", "translate(" + (heatmapWidth / 2) + "," + (heatmapHeight + 40) + ")")
    .text("Sell");
}

function execute() {
  d3.json(fname, function(error, data) {
    render(calc(data));
  });
}

execute();
